/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/analytics.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/analytics.js":
/*!**************************!*\
  !*** ./src/analytics.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Google Analytics module.\n */\n\n\n/**\n * Is universal analytics available.\n *\n * @type {boolean}\n */\nvar gaAvailable = true;\n\n\n/**\n * Allow all events of type(s) to be bubbled to, and captured by the root element.\n *\n * @type {boolean}\n */\nvar captureEventAtRoot = false;\n\n\n/**\n * The Backbone root element, usually $el.\n *\n * @type {object}\n */\nvar viewRootElement;\n\n\n/**\n * Is debug mode enabled.\n * If debug mode is enabled, all event details will be logged to the console.\n *\n * @type {boolean}\n */\nvar debugMode = false;\n\n\n/**\n * Default options for GA event.\n *\n * @type {object}\n */\nvar defaultEventOptions = {\n    'hitType': 'event',\n    'eventCategory': '',\n    'eventAction': '',\n    'nonInteraction': false\n};\n\n\n/**\n * Events queue.\n * The new method queueEvent can be used to add events to the queue.\n * Multiple GA events can be triggered from a single DOM event.\n *\n * @type {Array}\n */\nvar eventQueue = [];\n\n\n/**\n * This optional callback is called before the ga tracking is sent.\n * If the callback returns false the tracking data will not be sent.\n *\n * @type {function}\n */\nvar beforeTrackCallback;\n\n\n/**\n * This optional callback is called after the ga tracking is sent.\n * If the callback returns false the tracking data was not sent.\n *\n * @type {function}\n */\nvar afterTrackCallback;\n\n\n/**\n * If a click is a hyperlink do we want to follow it to its destination?\n *\n * @type {boolean}\n */\nvar followHrefs = true;\n\n\n/**\n * Attach the before/after custom callbacks.\n *\n * @param {object} customCallbacks The before tracking callback.\n */\nfunction attachCallbacks(customCallbacks) {\n    // Did we get any 'before/after event track' callbacks?\n    if (customCallbacks !== undefined && typeof customCallbacks === 'object') {\n        // Before handler?\n        if (customCallbacks.before !== undefined && typeof customCallbacks.before === 'function') {\n            beforeTrackCallback = customCallbacks.before;\n        }\n\n        // After handler?\n        if (customCallbacks.after !== undefined && typeof customCallbacks.after === 'function') {\n            afterTrackCallback = customCallbacks.after;\n        }\n    }\n}\n\n\n/**\n * Handle a specific element event.\n *  data-ga-event attached to element.\n *\n * @param {string} gaEventType The type of event triggered.\n * @param {object} gaElement The element the event was triggered from.\n * @param {string} gaElementType The type of element.\n * @param {object} gaEventOptions Default event options.\n * @returns {object} Event options.\n */\nfunction handleElementEvent(gaEventType, gaElement, gaElementType, gaEventOptions) {\n    // Create a copy of the default options object.\n    var gaOptions = $.extend({}, gaEventOptions);\n\n    // Did we get an event category?\n    gaOptions.eventCategory = (gaElement.data('ga-category') !== undefined)\n        ? gaElement.data('ga-category')\n        : gaElementType;\n\n    // Did we get an event action?\n    gaOptions.eventAction = (gaElement.data('ga-action') !== undefined)\n        ? gaElement.data('ga-action')\n        : gaEventType;\n\n    // Optional param label?\n    if (gaElement.data('ga-label') !== undefined) {\n        gaOptions.eventLabel = gaElement.data('ga-label');\n    }\n\n    // Optional param value?\n    if (gaElement.data('ga-value') !== undefined && typeof gaElement.data('ga-value') === 'number') {\n        gaOptions.eventValue = parseInt(gaElement.data('ga-value'));\n    }\n\n    // Optional param interactive?\n    if (gaElement.data('ga-interactive') !== undefined && typeof gaElement.data('ga-interactive') === 'boolean') {\n        gaOptions.nonInteraction = !gaElement.data('ga-interactive');\n    }\n\n    return gaOptions;\n}\n\n\n/**\n * Send the tracking event to google.\n * This can be prevented using the before callback.\n *\n * @param {object} event The triggered event.\n * @param {object} gaEventOptions Collection of event options.\n */\nfunction sendGAEvent(event, gaEventOptions) {\n    var deferred = $.Deferred();\n\n    if (gaAvailable === true && gaEventOptions.eventCategory != '' && gaEventOptions.eventAction != '') {\n        $(gaEventOptions).each(function(index, options) {\n            var sendGATracking = true;\n            var trackingGAObject = ga.getAll()[0];\n            var trackingGAObjectName = '';\n\n            if(trackingGAObject.get('name') != '') {\n                trackingGAObjectName  = trackingGAObject.get('name') + '.';\n            }\n\n            if (typeof beforeTrackCallback === 'function') {\n                // Call the callback, pass the event and the options object.\n                sendGATracking = beforeTrackCallback(event, options);\n            }\n\n            if (typeof ga === 'function' && sendGATracking === true) {\n\n                // Add callback to event options.\n                gaEventOptions.hitCallback = function() {\n\n                    // Log to console if in debug mode and console function is available (IE9).\n                    if (debugMode && window.console !== undefined) {\n                        console.log('GA Event: ', gaEventOptions);\n                    }\n\n                    // Process any events in the queue.\n                    if (eventQueue.length > 0) {\n                        var queueItemProcessed = 0;\n\n                        for (var eventIndex = 0; eventIndex < eventQueue.length; eventIndex++) {\n\n                            eventQueue[eventIndex].hitCallback = function() {\n                                // Log to console if in debug mode and console function is available (IE9).\n                                if (debugMode && window.console !== undefined) {\n                                    console.log('Q GA Event: ', eventQueue[queueItemProcessed]);\n                                }\n\n                                queueItemProcessed++;\n\n                                if (queueItemProcessed === eventQueue.length) {\n                                    eventQueue.length = 0;\n                                    deferred.resolve(true);\n                                }\n                            };\n\n                            ga(trackingGAObjectName + 'send', eventQueue[eventIndex]);\n                        }\n                    } else {\n                        deferred.resolve(true);\n                    }\n\n                };\n\n                ga(trackingGAObjectName + 'send', gaEventOptions);\n\n            } else {\n                deferred.resolve(false);\n            }\n\n        });\n    } else {\n        deferred.resolve(false);\n    }\n\n    return deferred.promise();\n}\n\n\n/**\n * Handle a generic event.\n *\n * @param {object} event The event that was triggered.\n */\nfunction handleEvent(event) {\n    // GA available ?\n    if (gaAvailable === true) {\n        var gaEventType = event.type;\n        var gaElement = $(event.currentTarget);\n        var gaElementType = gaElement[0].tagName;\n        var clickedTarget = $(event.target);\n\n        // Event options, required fields.\n        var gaEventDefaultOptions = $.extend({}, defaultEventOptions);\n        var gaEventOptions = [];\n\n        // Bubble up capture?\n        if (captureEventAtRoot && gaElement.data('ga-event') === undefined) {\n\n            // Travel up through the ancestors until a ga-event is found.\n            gaElement.parents().each(\n                function (index, element) {\n                    var parentElement = $(element);\n\n                    // Has the element got a ga-event handler?\n                    if ($(element).is(viewRootElement) === false && parentElement.data('ga-event') !== undefined && parentElement.data('ga-no-track') === undefined) {\n                        parentElement.trigger(gaEventType);\n                        return false;\n                    } else if ($(element).is(viewRootElement)) {\n                        return false;\n                    }\n                }\n            );\n\n        } else {\n            gaEventOptions = handleElementEvent(gaEventType, gaElement, gaElementType, gaEventDefaultOptions);\n        }\n\n        // Are we handling a click event on an a tag which has a href?\n        // If so, we need to sort out a little race condition! The GA Event is not guaranteed to beat the\n        // page redirection.\n        var handleLocationRaceCondition = false;\n\n        // If the element is <a> then check if should be followed.\n        if (followHrefs === true && gaElement[0].tagName.toLowerCase() === 'a' && gaElement[0].target == '') {\n            // Prevent any default actions.\n            event.preventDefault();\n\n            handleLocationRaceCondition = true;\n        }\n\n        // Trigger event if valid\n        sendGAEvent(event, gaEventOptions).done(function (gaTrackingSent) {\n            if (typeof afterTrackCallback === 'function') {\n                // Call the callback, pass the event and the flag that signified whether events sent.\n                afterTrackCallback(event, gaTrackingSent, gaEventOptions, eventQueue);\n            }\n\n            // Send the browser on its merry way.\n            if (handleLocationRaceCondition === true) {\n                window.location = gaElement[0].href;\n            }\n        });\n    }\n}\n\n\n/**\n * Attach custom form submit handlers.\n *\n * @param {object} element The element that will handle the event.\n * @param {object} event The event to handle.\n */\nfunction attachFormSubmitHandler(element, event) {\n    switch (event) {\n        case 'click':\n            handleFormPostClick(element);\n            break;\n        case 'enter':\n            handleFormPostEnter(element);\n            break;\n    }\n}\n\n\n/**\n * Handle the form submit.\n *\n * @param {object} form The form to submit.\n * @param {object} event The event that started everything, passed onto the before track callback (if defined).\n * @param {object} gaEventOptions The GA event options.\n */\nfunction submitForm(form, event, gaEventOptions) {\n    // Check form is valid.\n    var formValid = $(form)[0].checkValidity();\n\n    if (formValid === false) {\n        // Form has failed validation, configure event to reflect this.\n        gaEventOptions.eventLabel = 'submission failed, form data is invalid'\n    }\n\n    // Trigger event if valid\n    sendGAEvent(event, gaEventOptions);\n\n    // Submit the form.\n    if (formValid === true) {\n        form.submit();\n    }\n}\n\n\n/**\n * Automated form post using enter key.\n * This is accomplished using the event: formsubmit.enter on any input element.\n *\n * @param {object} element The element that will receive the enter key event.\n */\nfunction handleFormPostEnter(element) {\n    $(element).on('keydown', function (event) {\n        // Enter pressed?\n        if (event.keyCode === 13) {\n            event.preventDefault();\n\n            // Find the closest form.\n            var form =  $(element).closest('form');\n            var gaEventDefaultOptions = $.extend({}, defaultEventOptions);\n\n            if (submitForm !== undefined ) {\n                // Configure the event.\n                var gaEventOptions = handleElementEvent('keydown', form, form[0].tagName, gaEventDefaultOptions);\n\n                // Attempt to submit the form.\n                submitForm(form, event, gaEventOptions);\n            }\n        }\n    });\n}\n\n\n/**\n * Automated form post using an element click.\n * This is accomplished using the event: formsubmit.click on any element.\n *\n * @param {object} element The element that will receive the click event.\n */\nfunction handleFormPostClick(element) {\n    $(element).on('click', function (event) {\n        // Find the closest form.\n        var form =  $(element).closest('form');\n        var gaEventDefaultOptions = $.extend({}, defaultEventOptions);\n\n        if (submitForm !== undefined ) {\n            // Configure the event.\n            var gaEventOptions = handleElementEvent('click', $(element), $(element)[0].tagName, gaEventDefaultOptions);\n\n            // Attempt to submit the form.\n            submitForm(form, event, gaEventOptions);\n        }\n    });\n}\n\n\n/**\n * Attach GA events to all child elements of the specified element.\n *\n * @param {object} element The root element.\n * @param {boolean} captureAtRoot Capture all events at the root level (there must be a handler specified on the root).\n * @param {object} customCallbacks The before tracking callback.\n * @param {boolean} allowFollowHrefs If an event is attached to a hyperlink do you want to follow the link once the event has completed?\n * @param {boolean} enableDebugMode Enable console log event debugging.\n */\nfunction attachEventHandlers(element, captureAtRoot, customCallbacks, allowFollowHrefs, enableDebugMode) {\n    // Only continue if GA universal analytics is loaded.\n    if (typeof window.ga === 'function' && ga.create !== undefined) {\n        // Follow HREFs?\n        if (allowFollowHrefs !== undefined && typeof allowFollowHrefs === 'boolean') {\n            followHrefs = allowFollowHrefs;\n        }\n\n        // Activate debug mode?\n        if (enableDebugMode !== undefined && typeof enableDebugMode === 'boolean') {\n            debugMode = enableDebugMode;\n        }\n\n        // Assign the Backbone root element.\n        viewRootElement = element;\n\n        // Find all elements with a GA event.\n        var gaElements = element.find('[data-ga-event]');\n\n        // Did we get any 'before/after event track' callbacks?\n        if (customCallbacks !== undefined && typeof customCallbacks === 'object') {\n            // Before handler?\n            if (customCallbacks.before !== undefined && typeof customCallbacks.before === 'function') {\n                beforeTrackCallback = customCallbacks.before;\n            }\n\n            // After handler?\n            if (customCallbacks.after !== undefined && typeof customCallbacks.after === 'function') {\n                afterTrackCallback = customCallbacks.after;\n            }\n        }\n\n        // Capture all events at the root level?\n        if (captureAtRoot !== undefined && typeof captureAtRoot === 'boolean') {\n            captureEventAtRoot = captureAtRoot;\n        }\n\n        // Attach all events within the specified root element.\n        gaElements.each(function (idx, gaElement) {\n            var eventList = $(gaElement).data('ga-event').split(' ');\n\n            // We have to attach events individually, a custom event may exist in the list.\n            $(eventList).each(function (eventIdx, eventListName) {\n                var eventName = eventListName.split('.');\n\n                // Custom event?\n                if (eventName.length === 2) {\n                    switch (eventName[0]) {\n                        // Attach custom form submit handler.\n                        case 'formsubmit':\n                            attachFormSubmitHandler(gaElement, eventName[1]);\n                            break;\n                    }\n                } else {\n                    $(gaElement).on($(gaElement).data('ga-event'), function (event) {\n                        handleEvent(event);\n                    });\n                }\n\n            });\n\n        });\n\n    } else {\n        gaAvailable = false;\n    }\n}\n\n\n/**\n * Add a custom event to the event queue.\n *\n * @param {object} options Collection of event options.\n */\nfunction queueEvent(options) {\n    var gaOptions = $.extend({}, defaultEventOptions, options);\n\n    if (gaOptions.eventCategory !== '' && gaOptions.eventAction !== '') {\n        eventQueue.push(gaOptions);\n    } else {\n        throw 'Event options could not be added to the queue: Category and Action are mandatory.';\n    }\n}\n\n\n/**\n * Trigger a custom event track.\n *\n * @param {object} event The event.\n * @param {string} category The event tracking category.\n * @param {string} action The event tracking action.\n * @param {string|null} label The event tracking label.\n * @param {int|null} value The event tracking value.\n * @param {boolean|null} interactive Is the event classified as interactive?\n */\nfunction trackEvent(event, category, action, label, value, interactive) {\n    var deferred = $.Deferred();\n\n    // Track event can be used in isolation so check for the existence of the ga object.\n    if (gaAvailable === true && typeof window.ga === 'function' && ga.create !== undefined) {\n        var gaEventOptions = $.extend({}, defaultEventOptions);\n\n        // Defaults.\n        var gaEventType = '';\n        var gaElement = {};\n        var gaElementType = '';\n\n        // We may not have an event.\n        if (event !== null) {\n            gaEventType = event.type;\n            gaElement = $(event.target);\n            gaElementType = gaElement[0].tagName;\n        }\n\n        // Did we get an event category?\n        gaEventOptions.eventCategory = (category !== undefined)\n            ? category\n            : gaElementType;\n\n        // Did we get an event action?\n        gaEventOptions.eventAction = (action !== undefined)\n            ? action\n            : gaEventType;\n\n        // Optional param label?\n        if (label !== undefined) {\n            gaEventOptions.eventLabel = label;\n        }\n\n        // Optional param value?\n        if (value !== undefined && typeof value === 'number') {\n            gaEventOptions.eventValue = parseInt(value);\n        }\n\n        // Optional non interaction setting?\n        if (interactive !== undefined && typeof interactive === 'boolean') {\n            gaEventOptions.nonInteraction = !interactive;\n        }\n\n        sendGAEvent(event, gaEventOptions).done(function(gaEventSent) {\n            deferred.resolve(gaEventSent);\n        });\n    } else {\n        deferred.resolve(false);\n    }\n\n    return deferred.promise();\n}\n\n\n/**\n * Public methods.\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    attachEventHandlers: attachEventHandlers,\n    queueEvent: queueEvent,\n    trackEvent: trackEvent,\n    attachCallbacks: attachCallbacks\n});\n\n\n//# sourceURL=webpack:///./src/analytics.js?");

/***/ })

/******/ });